# Портфолио-проект: Графический движок

Этот проект создан как часть моего портфолио. Его цель — попрактиковать в объектно-ориентированном проектировании и архитектурных паттернах, создать площадку для личных экспериментов в этих дисциплинах.

Движок разработан с акцентом на простоту(этот термин тут нужно уточнять), расширяемость и возможность дальнейшего развития. Посмотрим, во что это может превратиться.

Что хотелось бы *попрогать*:
 - RAII, инциализация целиком внутри системы, нет глобальных данных. RAII не получится для подсистем зависящих друг от друга - необходима абстракция позволяющая инциализировать взаимо зависимые подсистемы.
 - Компонентная система для поддержки возможностей обьектов сцены + Boost.MultiIndex позволит выполнять покомпонентную фильтрацию.
 - Сцена - продвинутый контейнер на стероидах, фассад.
 - Pimpl подходит в маленький проекте чтобы отделить такие подсистемы как Graphics и Windows от их реализаций - OpenGL и SDL.
 - Blackboard. Для того чтобы в коде разрывать связи усложнающие его но не несущие значительного смысли и являющиеся деталями реализации решил использовать паттерн *blackboard*: модули обмениваются структурированными *пакетами* через общее пространство, что устраняет прямые зависимости, упрощает расширение и повышает модульность и гибкость системы. Возможно, *blackboard* также послужит ускорению разработки. Скажем, в ситуации, когда нужно устроить связь которой не уделено внимания в интерфейсах модулей. Не уделено внимания пока что или принципиально. Со временем, возможно, такой связи будет создано явное выражение в коде, и тогда необходимость в *blackboard* может отпасть. std::any помог для скрытия деталей реализации.

## Архитектурные особенности

Ключевым объектом приложения является сцена. Сцена выступает основным владельцем объектов и их компонентов, обеспечивая их горизонтальное взаимодействие.

### Объекты и компоненты

- **Объект**: базовый класс с уникальным идентификатором, именем и набором компонентов.
- **Компоненты**:
  - **Матрица трансформации**: описывает положение объекта в пространстве через матрицу трансформации.
  - **Графическая компонента**: отвечает за визуальные свойства, такие как геометрия и её цвет.
  - **Кинематическая компонента**: обеспечивает способность объекта перемещаться.

### Подсистемы

- **Графическая подсистема**: отвечает за отрисовку объектов.
- **Кинематическая подсистема**: управляет перемещением объектов.

Идея компонентов и подсистем немного похожа на нейроны, которые входят сразу во множество нейросетей, так и компоненты могут учавствовать в работе нескольких подсистем. Похожа, но не во всём.

Идея последующего расширения движка пока проста - это добавление новых компонентов (анимация, звук) и подсистем (звуковая, искусственный интеллект, анимационная).

Фасадом ко всем составляющим движка будет класс Game, который инкапсулирует сцену и подсистемы.

#### Сцена - продвинутый контейнер на стероидах
Я хочу реализовать идею сцены как продвинутого контейнера, своеобразного киберкомбайна. Идея, которая лежит в основе сцены, заключается в следующем: информация об объектах сцены хранится в объектах сцены и только в них. Сцена представляет собой небольшую базу данных, специализированную под задачи, характерные для подобного рода приложений. На начальном этапе самая интересная из них — это *покомпонентная фильтрация*. Что это такое объяснено ниже.

Попробую более формально записать задачи которые ставлю перед *сценой*:
- управлять объектами и их компонентами;
- выполнять поддержку горизонтального взаимодействия объктов сцены;
- выполнять эффективный поиск, предоставлять необходимые сведения об объектах — это вообще про все стандартные требования, думаю, такие есть в подобном контексте;
- предоставлять подсистемам *покомпонентную фильтрацию* сцены.

**Покомпонентная фильтрация** сцены — это приём, который позволит каждой подсистеме перебирать только те объекты, которые содержат необходимую компоненту. Планирую использовать `boost::multi_index` для индексации объектов по наличию определённых компонентов, таких как графическая или кинематическая. И хотя изначально в формулировках целей проекта присутствует простота, использование `boost::multi_index` может показаться противоречащим этому принципу. Однако, если сложность будет хорошо локализована и не распространится на другие части кода, то применение `boost::multi_index` будет оправданным, сохраняя принцип простоты проекта. Полагаю, это хороший прецедент для паттерна проектирования *Фасад*.

#### Подключение Boost.MultiIndex
Так как Boost очень большой, я решил воспользоваться тем, что он разбит на подмодули, каждый из которых представляет отдельную библиотеку. Нужный в проекте Boost.MultiIndex не исключение, и для него требуются дополнительные библиотеки из Boost, которых немало. Чтобы всё это не усложняло работу с репозиторием, я оформил это в два скрипта:
- boost-multi-index-setup-windows.ps1 загружает библиотеки, необходимые только для Boost.MultiIndex;
- remove-submodule-windows.ps1 удаляет следы присутствия подмодуля git переданного в аргументе.

#### Об использовании паттерна проектирования *singleton*
Я не разделяю негативного к нему отношения, которое выражают многие разработчики. Я нахожу его временами и местами полезным. Я знаю о его недочётах и, будучи уверен, что способен контролировать эти недочёты, не вижу ничего плохого в том, чтобы был тако й *singleton* на службе у программиста. Сейчас, например, в процессе разработки он позволяет временами решать задачи доступа к данным в подсистемах, которые ещё не достигли своей полной функциональности. В некотором смысле, это временные костыли. На текущем этапе разработки, используя *singleton*, я понял, что тут самое место подкорректировать семантику вызова. И оказалось, что там самое место для известной уже готовой сущности, необходимость использовать *singleton* в этом месте отпала. На мой взгляд *singleton* — рабочий инструмент.

Имя класс **ExplicitSingleton** - попытка подчеркнут в названии механику управляемого создания *одиночки*.

## Обработка ввода
Добавлена обработка сообщений от мыши, которую реализует SDL. Эта обработка только сохраняет состояние мыши - положение и состояние кнопок. Что делать при нажатиях и перемещениях будет решать InputProcessingSubsystem. Она будет запоминать историю манипуляций с мышью, и рассылать уведомления о происходящих изменениях. Позже добавлю обработку событий от клавиатуры.

## Интерактивность
Введены задатки интерактивности. Объектам добавлена collision sphere с которыми **RaycastSubsystem** выполняет hit test выпущенный из цента камеры в направлении расположения курсора мыши. При клике на такую сферу генерируется событие RayHitObject.

### На рассмотрении
  - Реакция объектов на события - behavior.
  - Самоаудит.
  - Сценарий инициализации.
  - Ведение журнала - logging.
  - Backends.
  - protobuff.
  - Управление памятью.
  - Поддержка скриптов.
  - Сделать систему "Документация в коде".
  - Нужен task tracking. Финальный коммит *интерактивности* получился очень большой.
  - Больший контроль над сборкой, над временем сборки. Суммирование времени затраченое на сборку в течении дня.
